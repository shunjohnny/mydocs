---
title: 10.3 フロントエンドの作成
tags:
  - FastAPI
---

## 10-3-1 フロントエンド

フロントエンドを下記の3つで作成する  
Javascript : ユーザーインターフェースの動作や、APIとの通信を作成  
html : ページの構造やコンテンツを定義  
css : ページのデザインやレイアウトを定義  

### Javascript

```javascript title="frontapp/app.js"
// グローバルスコープでFastAPIのURLを定義
const apiUrl = 'http://localhost:8001/memos/';

// 編集中のメモIDを保持する変数
let editingMemoId = null;

/**
* メッセージをアラートダイアログで表示する関数
*/
function displayMessage(message) {
    alert(message);
}

/**
* フォームをリセットし新規登録モードに戻す関数
*/
function resetForm() {
    // フォームのタイトルをリセット
    document.getElementById('formTitle').textContent = 'メモの作成';
    // 項目：タイトルをリセット
    document.getElementById('title').value = '';
    // 項目：詳細をリセット
    document.getElementById('description').value = '';
    // 更新実行ボタンを非表示にする
    document.getElementById('updateButton').style.display = 'none';
    // 新規登録ボタンを再表示
    document.querySelector('#createMemoForm button[type="submit"]').style.display = 'block';
    // 編集中のメモIDをリセット
    editingMemoId = null;
}

/**
* 新規登録：非同期関数
*/
async function createMemo(memo) {
    try {
        // APIに「POSTリクエスト」を送信してメモを作成します。
        // headersに'Content-Type'を'application/json'に設定し
        // JSON形式のデータを送信
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            // メモオブジェクトをJSON文字列に変換して送信
            body: JSON.stringify(memo)
        });
        // レスポンスのボディをJSONとして解析
        const data = await response.json();
        // レスポンスが成功した場合（HTTPステータスコード：200）
        if (response.ok) {
            // 成功メッセージをアラートで表示
            displayMessage(data.message);
            // フォームをリセットして新規入力状態に戻す
            resetForm();
            // メモ一覧を最新の状態に更新
            await fetchAndDisplayMemos();
        } else {
            // レスポンスが失敗した場合、エラーメッセージを表示
            if (response.status === 422) {
                // バリデーションエラーの場合
                displayMessage('入力内容に誤りがあります。');
            } else {
                displayMessage(data.detail);
            }
        }
    } catch (error) {
        // ネットワークエラーやその他の理由でリクエスト自体が失敗した場合
        console.error('メモ作成中にエラーが発生しました:', error);
    }
}

/**
* 更新：非同期関数
*/
async function updateMemo(memo) {
    try {
        // APIに「PUTリクエスト」を送信してメモを更新します。
        // headersに'Content-Type'を'application/json'に設定し
        // JSON形式のデータを送信
        const response = await fetch(`${apiUrl}${editingMemoId}`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(memo)
        });
        // レスポンスのボディをJSONとして解析
        const data = await response.json();
        // レスポンスが成功した場合（HTTPステータスコード：200）
        if (response.ok) {
            // 成功メッセージをアラートで表示
            displayMessage(data.message);
            // フォームをリセットして新規入力状態に戻す
            resetForm();
            // メモ一覧を最新の状態に更新
            await fetchAndDisplayMemos();
        } else {
            // レスポンスが失敗した場合、エラーメッセージを表示
            if (response.status === 422) {
                // バリデーションエラーの場合
                displayMessage('入力内容に誤りがあります。');
            } else {
                displayMessage(data.detail);
            }
        }
    } catch (error) {
        // ネットワークエラーやその他の理由でリクエスト自体が失敗した場合
        console.error('メモ更新中にエラーが発生しました:', error);
    }
}

/**
* 削除：非同期関数
*/
async function deleteMemo(memoId) {
    try {
        // APIに「DELETEリクエスト」を送信してメモを削除します。
        const response = await fetch(`${apiUrl}${memoId}`, {
            method: 'DELETE'
        });
        // レスポンスのボディをJSONとして解析
        const data = await response.json();
        // レスポンスが成功した場合（HTTPステータスコード：200）
        if (response.ok) {
            // 成功メッセージをアラートで表示
            displayMessage(data.message);
            // メモ一覧を最新の状態に更新
            await fetchAndDisplayMemos();
        } else {
            // レスポンスが失敗した場合、エラーメッセージを表示
            displayMessage(data.detail);
        }
    } catch (error) {
        // ネットワークエラーやその他の理由でリクエスト自体が失敗した場合
        console.error('メモ削除中にエラーが発生しました:', error);
    }
}

/**
* メモ一覧をサーバーから取得して表示する非同期関数
*/
async function fetchAndDisplayMemos() {
    try {
        // APIに「GETリクエスト」を送信してメモ一覧を取得します。
        const response = await fetch(apiUrl);
        // レスポンスが失敗した場合、エラーを投げます。
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        // レスポンスのボディをJSONとして解析
        const memos = await response.json();
        // HTML内のメモ一覧を表示する部分を取得
        const memosTableBody = document.querySelector('#memos tbody');
        // 一覧をクリア
        memosTableBody.innerHTML = '';
        // 取得したメモのデータを１つずつ設定
        memos.forEach(memo => {
            // 行を作成
            const row = document.createElement('tr');
            // 行の中身：タイトル、説明、編集と削除ボタン
            row.innerHTML = `
                <td>${memo.title}</td>
                <td>${memo.description}</td>
                <td>
                <button class="edit" data-id="${memo.memo_id}">編集</button>
                <button class="delete" data-id="${memo.memo_id}">削除</button>
                </td>
            `;
            // 作成した行をテーブルのbodyに追加
            memosTableBody.appendChild(row);
        });
    } catch (error) {
        // ネットワークエラーやその他の理由でリクエスト自体が失敗した場合
        console.error('メモ一覧の取得中にエラーが発生しました:', error);
    }
}

/**
* 特定のメモを編集するための非同期関数
*/
async function editMemo(memoId) {
    // 編集するメモのIDをグローバル変数に設定
    editingMemoId = memoId;
    // サーバーから特定のIDのメモのデータを取得するリクエストを送信
    const response = await fetch(`${apiUrl}${memoId}`);
    // レスポンスのJSONを解析し、メモデータを取得
    const memo = await response.json();
    // レスポンスが正常でなければ、エラーメッセージを表示し、処理を終了
    if (!response.ok) {
        await displayMessage(memo.detail);
        return;
    }
    // 取得したメモのタイトルと説明をフォームに設定
    document.getElementById('title').value = memo.title;
    document.getElementById('description').value = memo.description;
    // === フォーム ===
    // フォームの見出しを「メモの編集」に更新
    document.getElementById('formTitle').textContent = 'メモの編集';
    // 更新実行ボタンを表示にする
    document.getElementById('updateButton').style.display = 'block';
    // 新規登録ボタンを非表示にする
    document.querySelector('#createMemoForm button[type="submit"]').style.display = 'none';
}

/**
* ドキュメントの読み込みが完了した後に実行されるイベントリスナー
* つまり、ドキュメントの読み込みが完了した時点で、以下のコードが実行されます。
*/
document.addEventListener('DOMContentLoaded', () => {
    // フォームの要素を取得
    const form = document.getElementById('createMemoForm');

    // フォームの送信イベントに対する処理を設定
    form.onsubmit = async (event) => {
        // フォームのデフォルトの送信動作を防止
        event.preventDefault();
        // タイトルと説明の入力値を取得
        const title = document.getElementById('title').value;
        const description = document.getElementById('description').value;
        // メモオブジェクトを作成
        const memo = { title, description };

        // 編集中のメモIDがある場合は更新、なければ新規作成を実行
        if (editingMemoId) {
            await updateMemo(memo);
        } else {
            await createMemo(memo);
        }
    };

    // 更新ボタンのクリックイベントに対する処理を設定
    document.getElementById('updateButton').onclick = async () => {
        // タイトルと説明の入力値を取得
        const title = document.getElementById('title').value;
        const description = document.getElementById('description').value;
        // 更新関数を実行
        await updateMemo({ title, description });
    };

    // メモ一覧テーブル内のクリックイベントを監視
    // つまりメモ一覧テーブル内の任意のクリックに対してイベントリスナーを設定
    document.querySelector('#memos tbody').addEventListener('click', async (event) => {
        // クリックされた要素が編集ボタンだった場合の処理
        if (event.target.className === 'edit') {
            // クリックされた編集ボタンからメモIDを取得
            const memoId = event.target.dataset.id;
            // 編集関数を実行
            await editMemo(memoId);
        // クリックされた要素が削除ボタンだった場合の処理
        } else if (event.target.className === 'delete') {
            // クリックされた削除ボタンからメモIDを取得
            const memoId = event.target.dataset.id;
            // 削除関数を実行
            await deleteMemo(memoId);
        }
    });
});

/**
* ドキュメントの読み込みが完了した時にメモ一覧を表示する関数を呼び出す
*/
document.addEventListener('DOMContentLoaded', fetchAndDisplayMemos);
```

### html

```html title="frontapp/index.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- ビューポートの設定: スケーラブルなデザインを実現するための基本設定 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memo App</title>
    <!-- 外部CSSファイルのリンク -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- アプリケーションのタイトル -->
    <h1>Memo App</h1>
    <!-- メモ作成フォームのコンテナ -->
    <div class="form-container">
        <h2 id="formTitle">メモの作成</h2>
        <form id="createMemoForm">
            <div>
                <!-- タイトル入力フィールド -->
                <label for="title">タイトル</label>
                <input type="text" id="title" placeholder="タイトルを入力" required />
            </div>
            <div>
                <!-- 詳細入力フィールド -->
                <label for="description">詳細</label>
                <textarea id="description" placeholder="詳細を入力"></textarea>
            </div>
            <div class="button-container">
                <!-- メモ新規登録ボタン -->
                <button type="submit">新規登録</button>
                <!-- 更新ボタン（初期状態では非表示） -->
                <button type="button" id="updateButton" style="display: none;">更新実行</button>
            </div>
        </form>
    </div>
    <!-- 区切り線 -->
    <hr>
    <!-- メモの一覧を表示するテーブル -->
    <table id="memos">
        <thead>
            <tr>
                <th>タイトル</th>
                <th>詳細</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody>
            <!-- JavaScriptによってメモの一覧がここに挿入される -->
        </tbody>
    </table>
    <!-- JavaScriptファイルのリンク -->
    <script src="app.js"></script>
</body>
</html>
```

### css

```css title="frontapp/styles.css"
/* ベース設定: 全体に適用されるスタイル */
body {
    /* 使用するフォントファミリー */
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    /* 中央揃えにするためのマージン */
    margin: 0 auto;
    /* 全体のコンテンツの最大幅 */
    max-width: 600px;
    /* 全体のパディング */
    padding: 20px;
    /* 背景色 */
    background-color: #f4f4f4;
}

/* 見出しのスタイル */
h1, h2 {
    /* 見出しのテキスト色 */
    color: #2c3e50;
}

/* フォームコンテナのスタイル */
.form-container {
    /* 背景色 */
    background-color: #ffffff;
    /* 境界線 */
    border: 1px solid #dddddd;
    /* 下マージン */
    margin-bottom: 20px;
    /* 内部パディング */
    padding: 20px;
    /* 影 */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    /* 角の丸み */
    border-radius: 5px;
}

/* ラベルのスタイル */
label {
    /* ブロック要素として表示 */
    display: block;
    /* 下マージン */
    margin-bottom: 5px;
    /* 太字 */
    font-weight: bold;
}

/* 入力項目のスタイル */
input[type="text"], textarea {
    /* 境界線 */
    border: 1px solid #cccccc;
    /* 下マージン */
    margin-bottom: 20px;
    /* 内部パディング */
    padding: 10px;
    /* 全幅から境界線とパディングを差し引いた幅 */
    width: calc(100% - 22px);
    /* 角の丸み */
    border-radius: 3px;
    /* 内側に影 */
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* =====【テーブル】===== */
/* テーブルのスタイル */
table {
    /* セルの境界線を一つに */
    border-collapse: collapse;
    /* 幅 */
    width: 100%;
    /* 背景色 */
    background-color: #ffffff;
    /* 影 */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    /* 角の丸み */
    border-radius: 5px;
    /* 内部の要素がはみ出さないように */
    overflow: hidden;
}
/* テーブルヘッダーとセルのスタイル */
th, td {
    /* 境界線 */
    border: 1px solid #dddddd;
    /* パディング */
    padding: 10px;
    /* テキストの配置 */
    text-align: left;
}
/* テーブルヘッダーのスタイル */
th {
    /* 背景色 */
    background-color: #3498db;
    /* テキスト色 */
    color: white;
}

/* =====【ボタン】===== */
/* ボタンのスタイル */
button {
    /* 背景色 */
    background-color: #3498db;
    /* 境界線なし */
    border: none;
    /* テキスト色 */
    color: white;
    /* ホバー時のカーソル */
    cursor: pointer;
    /* パディング */
    padding: 10px 15px;
    /* 右マージン */
    margin-right: 10px;
    /* 角の丸み */
    border-radius: 3px;
    /* 背景色変更のアニメーション */
    transition: background-color 0.3s ease;
}
button:hover {
    /* ホバー時の背景色 */
    background-color: #055b93;
}

/* 更新実行ボタンのスタイル */
#updateButton {
    /* 背景色 */
    background-color: rgb(12, 185, 12);
}
#updateButton:hover {
    /* ホバー時の背景色 */
    background-color: #218838;
}

/* 編集ボタンのスタイル */
.edit {
    /* 背景色 */
    background-color: #f7c705cf;
}
.edit:hover {
    /* ホバー時の背景色 */
    background-color: #b79407df;
}

/* 削除ボタンのスタイル */
.delete {
    /* 背景色 */
    background-color: #e8210b;
}
.delete:hover {
    /* ホバー時の背景色 */
    background-color: #a53005df;
}

/* 編集・削除ボタンのスタイル */
.edit, .delete {
    /* パディング */
    padding: 5px 10px;
    /* テキスト色 */
    color: white;
    /* テキストの下線を消す */
    text-decoration: none;
    /* 角の丸み */
    border-radius: 3px;
}
```